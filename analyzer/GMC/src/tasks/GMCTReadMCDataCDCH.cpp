////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// GMCTReadMCDataCDCH                                                         //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     GeantTrack                                                             //
//     DCGeantStep                                                            //
//     DCHHit                                                                 //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/GMCTReadMCDataCDCHGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

#include "TROOT.h"
#include "TString.h"
#include "TClass.h"
//#include "TVector3.h"
#include "TFile.h"
#include "TMath.h"


#include "generated/GMCAnalyzer.h"
#include "generated/GMCConfigToForm.h"
#include "generated/GMCMCRunHeader.h"
#include "generated/GMCGeantTrack.h"
#include "generated/GMCDCGeantStep.h"
//#include "generated/GMCPXGeantStep.h"
#include "generated/GMCDCHHit.h" 

#include "generated/GMCEventLoop.h"

#include "util/CreateClusters.h"
#include "util/ClusterSize.h"
#include "tasks/GMCTReadMCDataCDCH.h"
#include "ROMEiostream.h"

#include "CellGeometryHandle.hh"
#include "utilFunctions.hh"

#include "CLHEP/Vector/ThreeVector.h"

// uncomment if you want to include headers of all folders
//#include "GMCAllFolders.h"


ClassImp(GMCTReadMCDataCDCH)

//______________________________________________________________________________
void GMCTReadMCDataCDCH::Init() {

  //instance the geometry
  fGeometry = GeometrySrvHndl::Instance();
  if(!fGeometry->GetCellHandle())
    fGeometry->makeDetectors();

  _minimumEnergy = GetSP()->GetHitEnergyCut();
}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::BeginOfRun(){
}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::Event() {

  if (gAnalyzer->GetCurrentEventNumber()%100==0 ) { printf("\n ***** ReadMCDataCDCH Load event %lld ************************ \n",gAnalyzer->GetCurrentEventNumber()); }
  LoadEvent(gAnalyzer->GetCurrentEventNumber());

  gAnalyzer->SetDCHHitSize(0);
  DefineHitsInDCH2();
//  DefineHitsInDCH();
  
//  DefineHitsInMPX();

}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::LoadEvent(Int_t nev) {

  fBrDataDch=gAnalyzer->GetDCGeantSteps();
  fBrDataTrk=gAnalyzer->GetGeantTracks();
}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::DefineHitsInDCH() {

  Int_t ah_trkId;
  Int_t ah_chbId;
  Double_t ah_edep;
  TVector3 *ah_posIn, *ah_posOut;
  Int_t NrHits = 0;

  Bool_t fLoop = true;
  int istep = 0;
  for (;istep<fBrDataDch->GetEntries();istep++) {
    GMCDCGeantStep *aStep = (GMCDCGeantStep *)fBrDataDch->At(istep);
    ah_posOut = (TVector3*)aStep->GetfPosEnding();
    ah_trkId = aStep->GetfTrackID();
    ah_chbId = aStep->GetfChamberNr();
    ah_edep = aStep->GetfEdep();
    ah_posIn = (TVector3*)aStep->GetfPos();
    if (istep == fBrDataDch->GetEntries()-1) fLoop = false;

    while(fLoop) {
      istep++;
      GMCDCGeantStep *aStep = (GMCDCGeantStep *)fBrDataDch->At(istep);
      if (ah_chbId == aStep->GetfChamberNr()) {
        //same tube
        if (ah_trkId == aStep->GetfTrackID()) {
          //same track
          ah_posOut = (TVector3*)aStep->GetfPosEnding();
          ah_edep += aStep->GetfEdep();
        }
        else {
          fLoop = false;
          istep -= 1;
        }

        if (istep == fBrDataDch->GetEntries()-1) fLoop = false;
      }
      else {
        fLoop = false;
        istep -= 1;
      }
    }

    TVector3 TrkVector(ah_posOut->X()-ah_posIn->X(),
		       ah_posOut->Y()-ah_posIn->Y(),
		       ah_posOut->Z()-ah_posIn->Z());

    gAnalyzer->SetDCHHitSize(NrHits+1);
    GMCDCHHit *ahit = gAnalyzer->GetDCHHitAt(NrHits);

    DCACalculation(ah_chbId,*ah_posIn,TrkVector);

    printf(" \n ----> Tube nr. %d, track Id = %d : PCA = (%5.3f,%5.3f,%5.3f), distance = %7.5f mm  Energy deposit = %f\n",ah_chbId,ah_trkId,fCApoint.X(),fCApoint.Y(),fCApoint.Z(),fDCA,ah_edep);;

    ahit->SetfCellId(ah_chbId);
    ahit->SetfTrkIDofHit(ah_trkId);
    ahit->SetfxPCA(fCApoint.X());
    ahit->SetfyPCA(fCApoint.Y());
    ahit->SetfzPCA(fCApoint.Z());
    ahit->SetfEntranceX(ah_posIn->X());
    ahit->SetfEntranceY(ah_posIn->Y());
    ahit->SetfEntranceZ(ah_posIn->Z());
    ahit->SetfImpact(fDCA);
    ahit->SetfTotalEnergyLoss(ah_edep);
    ahit->SetfLength(TrkVector.Mag());
    DefineClustersInDCH(ahit,*ah_posIn,TrkVector);

    fLoop = true;
    NrHits++;

  }

}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::DefineHitsInDCH2() {

//  Int_t ah_trkId;
//  Int_t ah_chbId;
//  Double_t ah_edep;
//  TVector3 *ah_posIn, *ah_posOut;
  Int_t NrHits = 0;

  double hit_dca;
  CLHEP::Hep3Vector hit_pca;

  DriftCellHitMap hitmap;
  hitmap.clear();
  fillHitMap( hitmap );

  for(DriftCellHitMap::const_iterator idcell = hitmap.begin(); idcell != hitmap.end(); ++idcell) {
    int dcell_id = idcell->first;
    fGeometry->GetCellHandle()->SelectCellDet(dcell_id);
    CLHEP::Hep3Vector const& mid   = fGeometry->GetCellHandle()->GetCellCenter();
    CLHEP::Hep3Vector const& w     = fGeometry->GetCellHandle()->GetCellDirection();
//    TVector3 wpos( fGeometry->GetCellHandle()->GetCellCenter().x(),
//        fGeometry->GetCellHandle()->GetCellCenter().y(),
//        fGeometry->GetCellHandle()->GetCellCenter().z()
//        );
//
//    TVector3 wdir( fGeometry->GetCellHandle()->GetCellDirection().x(),
//        fGeometry->GetCellHandle()->GetCellDirection().y(),
//        fGeometry->GetCellHandle()->GetCellDirection().z()
//        );

//    double cellHalfLength         = fGeometry->GetCellHandle()->GetCellHalfLength();


    //vector<int> const& ihits = idcell->second;
    std::vector<GMCDCGeantStep *> const& ihits = idcell->second;

    std::map<int,GMCDCHHit *> hitPerTrk;
    std::map<int,GMCDCHHit *>::iterator hitPerTrk_it;

    std::map<int,const TVector3 *> hitEndPerTrk;
    std::map<int,const TVector3 *>::iterator hitEndPerTrk_it;

    for( size_t i=0; i<ihits.size(); i++ ) {

      GMCDCGeantStep& hit = *(ihits.at(i));

      hitPerTrk_it = hitPerTrk.find(hit.GetfTrackID());
      hitEndPerTrk_it = hitEndPerTrk.find(hit.GetfTrackID());

      if ( hitPerTrk_it == hitPerTrk.end() ) {
        gAnalyzer->SetDCHHitSize(NrHits+1);
        GMCDCHHit *ahit = gAnalyzer->GetDCHHitAt(NrHits);
        ++NrHits;
        hitPerTrk.insert( std::pair<int,GMCDCHHit *>( hit.GetfTrackID(), ahit ) );
        hitEndPerTrk.insert( std::pair<int,TVector3 *>( hit.GetfTrackID(), hit.GetfPosEnding() ) );

        ahit->SetfCellId( dcell_id );
        ahit->SetfTrkIDofHit( hit.GetfTrackID() );
//        ahit->SetfxPCA(fCApoint.X());
//        ahit->SetfyPCA(fCApoint.Y());
//        ahit->SetfzPCA(fCApoint.Z());
        ahit->SetfEntranceX( hit.GetfPos()->X() );
        ahit->SetfEntranceY( hit.GetfPos()->Y() );
        ahit->SetfEntranceZ( hit.GetfPos()->Z() );
        ahit->SetfEntranceMomX( hit.GetfMomentum()->X() );
        ahit->SetfEntranceMomY( hit.GetfMomentum()->Y() );
        ahit->SetfEntranceMomZ( hit.GetfMomentum()->Z() );
//        ahit->SetfImpact(fDCA);
        ahit->SetfTotalEnergyLoss( hit.GetfEdep() );
	    ahit->SetfGlobalTime( hit.GetfGlobalTime() );
	    ahit->SetfToF( hit.GetfProperTime() );
        ahit->SetfLength( hit.GetfStepLen() );

      } else {
        GMCDCHHit *ahit = hitPerTrk_it->second;
        ahit->SetfTotalEnergyLoss( ahit->GetfTotalEnergyLoss() + hit.GetfEdep() );
        ahit->SetfLength( ahit->GetfLength() + hit.GetfStepLen() );
        hitEndPerTrk_it->second=hit.GetfPos();
      }

    }

    //FIXME!!! Tracks Pile-up not taken into account!!!

    for ( hitPerTrk_it=hitPerTrk.begin(); hitPerTrk_it!=hitPerTrk.end(); ++hitPerTrk_it ) {
      GMCDCHHit *ahit = hitPerTrk_it->second;
      CLHEP::Hep3Vector pos(ahit->GetfEntranceX(),ahit->GetfEntranceY(),ahit->GetfEntranceZ());
      TVector3 TrkVector, posIn(pos.x(),pos.y(),pos.z());
      if (ahit->GetfLength()<_minimumLength) {
        LinePointPCA pca(mid, w, pos);
        hit_dca = pca.dca();
        hit_pca = pca.pca();
      } else {

        // Step is not a point. Calculate the distance between two lines.
        const TVector3 *endpos=hitEndPerTrk[hitPerTrk_it->first];
        CLHEP::Hep3Vector mom(endpos->X(),endpos->Y(),endpos->Z());
        mom -= pos;
        TrkVector.SetXYZ(mom.x(),mom.y(),mom.z());
        mom = mom.unit();

        TwoLinePCA pca( mid, w, pos, mom);
        CLHEP::Hep3Vector const& p2 = pca.point2();

        //          if( (pos-p2).mag()<=length && (pos-p2).dot(mom)<=0 ) {

        // If the point of closest approach is within the step and wire - thats it.
        //double hit_dca_l = pca.dca();

        hit_pca = pca.point1();
        //          sign=w.cross(mom).dot(hit_pca-p2);

        //small correction (~10mum) forr track is not line
        double dl=(p2-pos).perp();
        CLHEP::Hep3Vector b(0,0,gAnalyzer->GetGSP()->GetBz());
        CLHEP::Hep3Vector pcurv=p2;//+b.cross(mom)/mom.perp()*dl*dl/2/(mom.perp()*3);
        hit_dca=(pcurv-hit_pca).mag();

      }
      if ( hit_dca > fGeometry->GetCellHandle()->GetCellRad() ) { hit_dca = fGeometry->GetCellHandle()->GetCellRad(); }
      ahit->SetfxPCA(hit_pca.x());
      ahit->SetfyPCA(hit_pca.y());
      ahit->SetfzPCA(hit_pca.z());
      ahit->SetfImpact(hit_dca);
//      ahit->SetfLength(TrkVector.Mag());
      if(GetSP()->GetSimulateClusters())
        DefineClustersInDCH(ahit,posIn,TrkVector);
//      printf(" \n ----> Tube nr. %d, track Id = %d : PCA = (%5.3f,%5.3f,%5.3f), distance = %7.5f mm  Energy deposit = %f\n",ahit->GetfCellId(),ahit->GetfTrkIDofHit(),hit_pca.x(),hit_pca.y(),hit_pca.z(),hit_dca,ahit->GetfTotalEnergyLoss());
    }

  }

  int nclust=0;
  for(int i=0;i<gAnalyzer->GetDCHHitSize();i++){
     GMCDCHHit *ah = gAnalyzer->GetDCHHitAt(i);
     nclust+=ah->GetfNrClusters();
  }
  if (gAnalyzer->GetCurrentEventNumber()%100==0 ) { std::cout<<"nhits "<<gAnalyzer->GetDCHHitSize()<<" nclust "<<nclust<<std::endl; }
  //  ProcInfo_t info;
  //  gSystem->GetProcInfo(&info);
  //  std::cout<<"Memory usage "<<info.fMemVirtual<<" "<<info.fMemResident<<std::endl;
 
}

//_____________________________________________________________________________
Bool_t GMCTReadMCDataCDCH::DCACalculation(Int_t nCh, TVector3 &pTrk, TVector3 &trkDir) {

  //wire position: copied from Geant4 B2aDetectorConstruction.cc
//  TVector3 wpos = fGeometry->Getwire_pos(nCh);
//
//  TVector3 wdir = fGeometry->Getwire_dir(nCh);
  fGeometry->GetCellHandle()->SelectCellDet(nCh);
  TVector3 wpos( fGeometry->GetCellHandle()->GetCellCenter().x(),
      fGeometry->GetCellHandle()->GetCellCenter().y(),
      fGeometry->GetCellHandle()->GetCellCenter().z()
      );

  TVector3 wdir( fGeometry->GetCellHandle()->GetCellDirection().x(),
      fGeometry->GetCellHandle()->GetCellDirection().y(),
      fGeometry->GetCellHandle()->GetCellDirection().z()
      );

  if (trkDir != TVector3(0.,0.,0.)) {

    TVector3 delta(wpos - pTrk);
    TVector3 crossprod = trkDir.Cross(wdir);

    Double_t detParT = delta.Dot(crossprod.Cross(-wdir));
    Double_t determ = trkDir.Dot(crossprod.Cross(-wdir));

    Double_t parT = detParT/determ;

    fCApoint = pTrk + trkDir*parT;

    fDCA = fabs(delta.Dot(crossprod));
    fDCA /= crossprod.Mag();//diff.Mag();
  }
  else {

    fDCA = TMath::Sqrt(TMath::Power(wpos.Y()-pTrk.Y(),2) +
                       TMath::Power(wpos.Z()-pTrk.Z(),2));

    fCApoint = pTrk;
  }

  return 1;
}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::DefineClustersInDCH(GMCDCHHit *ah,TVector3 &pTrk, TVector3 &trkDir) {

//  TVector3 wdir = fGeometry->Getwire_dir(ah->GetfCellId());
//  TVector3 wpos = fGeometry->Getwire_pos(ah->GetfCellId());
  fGeometry->GetCellHandle()->SelectCellDet(ah->GetfCellId());
  TVector3 wpos( fGeometry->GetCellHandle()->GetCellCenter().x(),
      fGeometry->GetCellHandle()->GetCellCenter().y(),
      fGeometry->GetCellHandle()->GetCellCenter().z()
      );

  TVector3 wdir( fGeometry->GetCellHandle()->GetCellDirection().x(),
      fGeometry->GetCellHandle()->GetCellDirection().y(),
      fGeometry->GetCellHandle()->GetCellDirection().z()
      );


  if (trkDir != TVector3(0.,0.,0.)) {
    //CreateClusters *clusters = new CreateClusters(ah->GetfLength());
    CreateClusters *clusters = new CreateClusters(ah->GetfLength(),ah->GetfTotalEnergyLoss());

    Int_t ncl = clusters->GetNrClusters();
    TVector3 clrpos;

    ah->SetfNrClusters(ncl);
    ah->SetfClsDistanceSize(ncl);
    ah->SetfClsDistanceSmearedSize(ncl);
    ah->SetfClsChargeSize(ncl);
    ah->SetfClsPathPosSize(ncl);

    Double_t  dist, par;
    Int_t sumc = 0;
    for (int icl=0;icl<ncl;icl++) {
      dist = clusters->GetClusterPositionAt(icl);
      par = dist/ah->GetfLength();
      clrpos = pTrk + par*trkDir;

      ah->SetfClsPathPosAt(icl,dist);

      TVector3 diff = clrpos - wpos;
      Double_t sdist = TMath::Sqrt(diff.Mag2()-TMath::Power(diff.Dot(wdir),2));

      ah->SetfClsDistanceAt(icl,sdist);

      ah->SetfClsChargeAt(icl,clusters->GetClusterChargeAt(icl));
      sumc += clusters->GetClusterChargeAt(icl);

      ah->SetfClsDistanceSmearedAt(icl,sdist+clusters->GetClusterSmearingAt(icl));

    }
   
    ah->SetfTotalCharge(sumc);

    delete clusters;
  }
}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::fillHitMap ( DriftCellHitMap& hitmap ) {
  int nentries=fBrDataDch->GetEntries();
  for (int istep=0;istep<nentries;istep++) {
    GMCDCGeantStep *aStep = (GMCDCGeantStep *)fBrDataDch->At(istep);
    if( (aStep->GetfEdep()-aStep->GetfNoIEdep())<_minimumEnergy ) continue; // Skip steps with very low energy deposition
    hitmap[aStep->GetfChamberNr()].push_back(aStep);
  }
}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::EndOfRun() {
}

//______________________________________________________________________________
void GMCTReadMCDataCDCH::Terminate() {
}

