////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// GMCTMCGenerator                                                            //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     Event                                                                  //
//     MCTrack                                                                //
//     MCHit                                                                  //
//     Hit                                                                    //
//                                                                            //
// This task contains the following histgrams :                               //
//    HTIME                                                                   //
//                                                                            //
// The histograms/graph are created and saved automaticaly by the task.       //
//                                                                            //
// The following method can be used to get a handle of the histogram/graph :  //
//                                                                            //
// Get<Histogram/Graph Name>()                                                //
//                                                                            //
// For histogram/graph arrays use :                                           //
//                                                                            //
// Get<Histogram/Graph Name>At(Int_t index)                                   //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/GMCTMCGeneratorGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

#include "generated/GMCAnalyzer.h"
#include "util/Geometry.h"
#include "tasks/GMCTMCGenerator.h"
#include "ROMEiostream.h"

#include "TRandom3.h"


//change if you want to see drift time distribution hist
#define H_TIME 0
//change if you want to rotate the detector by ROTANGLE
#define ROTATE 0
#define ROTANGLE 0.21
//change if you want that the central tube has a different staggering
#define stagCentral 0
#define dstagCentral 2.5


double T(double D){return((29.95*D) + 3.087*D*D);} //ns
double D(double T) { return ((-29.95 + sqrt(29.95*29.95 + 4.*3.087*T))/(2.*3.087));}


// uncomment if you want to include headers of all folders
//#include "GMCAllFolders.h"

ClassImp(GMCTMCGenerator)


//______________________________________________________________________________
void GMCTMCGenerator::Init()
{

  gAnalyzer->SetMCTrackSize(1);
  
}

//______________________________________________________________________________
void GMCTMCGenerator::BeginOfRun()
{
   
}

//______________________________________________________________________________
void GMCTMCGenerator::Event()
{

  
  //MC TRACK GENERATION
  
  Double_t x0 =(gAnalyzer->GetGSP()->GetxBeam()) ;
  gAnalyzer->GetMCTrackAt(0)->Setx0(x0);

  Double_t y0 = gRandom->Uniform(-6.,15.);// gRandom->Gaus(0.,gAnalyzer->GetGSP()->GetyBeamSpot());
  gAnalyzer->GetMCTrackAt(0)->Sety0(y0);
  
  Double_t z0 =-45;//gAnalyzer->GetGSP()->GetzBeam() ;
  gAnalyzer->GetMCTrackAt(0)->Setz0(z0);

  Double_t theta =gRandom->Uniform(-(gAnalyzer->GetGSP()->GetbeamSpread()), gAnalyzer->GetGSP()->GetbeamSpread());
  gAnalyzer->GetMCTrackAt(0)->Settheta(theta);

  Double_t phi = 0.;
  gAnalyzer->GetMCTrackAt(0)->Setphi(phi);

  GenerateHits();


  //time distribution histogramm
  if(H_TIME==1){
  for(Int_t j=0; j<gAnalyzer->GetHitSize();j++){
         
      GetHTIME()->Fill(gAnalyzer->GetHitAt(j)->Gett_meas());
  }
  GetHTIME()->Draw();
  }
}

//______________________________________________________________________________
void GMCTMCGenerator::EndOfRun()
{

}

//______________________________________________________________________________
void GMCTMCGenerator::Terminate()
{
 
}

//Functions

Int_t GMCTMCGenerator::Intersection(TVector3 center, TVector3 *p1, TVector3 *p2) {
 
  Double_t R = gAnalyzer->GetGSP()->Gettube_radius();
  Double_t thetai=gAnalyzer->GetMCTrackAt(0)->Gettheta();
  Double_t phii=gAnalyzer->GetMCTrackAt(0)->Getphi();

  Double_t vx=sin(thetai)*sin(phii);
  Double_t vy=sin(thetai)*cos(phii);
  Double_t vz=cos(thetai);

  Double_t xi=gAnalyzer->GetMCTrackAt(0)->Getx0();
  Double_t yi=gAnalyzer->GetMCTrackAt(0)->Gety0();
  Double_t zi=gAnalyzer->GetMCTrackAt(0)->Getz0();

  Double_t a=  vy*vy + vz*vz;
  Double_t b=  2*vy*(yi-center.Y()) + 2*vz*(zi-center.Z());
  Double_t c=  (yi-center.Y())*(yi-center.Y()) + (zi-center.Z())*(zi-center.Z()) - R*R;
  
  if((b*b - 4*a*c)<0){
 
    return 0;
  }
  else  if((b*b - 4*a*c)>0){
 
    Double_t tP1=(-b-sqrt(b*b-4*a*c))/(2*a); 
    p1->SetX(vx*tP1+xi);
    p1->SetY(vy*tP1+yi);
    p1->SetZ(vz*tP1+zi);
    
    Double_t tP2=(-b+sqrt(b*b-4*a*c))/(2*a);
    p2->SetX(vx*tP2+xi);
    p2->SetY(vy*tP2+yi);
    p2->SetZ(vz*tP2+zi);
        
 return 1;
 }
  return 0;
}


void GMCTMCGenerator::SetClustersGlobal(TVector3 p1,TVector3 p2,TVector3 c,Int_t tube_num){
  

  TVector3 vector= p2-p1;
  TVector3 versor=vector.Unit();
  Double_t distance=vector.Mag();
  Double_t mean_clus=distance/(gAnalyzer->GetGSP()->Getlambda());
  Double_t Nclust=gRandom->Poisson(mean_clus);
  gAnalyzer->GetMCTrackAt(0)->Setnclusters(Nclust);
  gAnalyzer->GetMCTrackAt(0)->Setdrift_distanceSize(Nclust);
  gAnalyzer->GetMCTrackAt(0)->Setdrift_timeSize(Nclust);
 
  gAnalyzer->SetMCHitSize(gAnalyzer->GetMCHitSize()+1);//new MCHit
  gAnalyzer->GetMCHitAt(gAnalyzer->GetMCHitSize()-1)->Setnclusters(Nclust);
  gAnalyzer->GetMCHitAt(gAnalyzer->GetMCHitSize()-1)->SetclusterYSize(Nclust);
  gAnalyzer->GetMCHitAt(gAnalyzer->GetMCHitSize()-1)->SetclusterZSize(Nclust);
   
  
  Double_t t_meas=999999.;
  Double_t t_drift;

  for(Int_t i=0; i<Nclust; i++){  

    Double_t random_s=gRandom->Uniform(0.,distance);   
    TVector3 cluster= p1 + versor*random_s;
    TVector3 cluster_local=(cluster-c);
    gAnalyzer->GetMCHitAt(gAnalyzer->GetMCHitSize()-1)->SetclusterYAt(i,cluster.Y());
    gAnalyzer->GetMCHitAt(gAnalyzer->GetMCHitSize()-1)->SetclusterZAt(i,cluster.Z());
    Double_t clus_d=sqrt(pow(cluster_local.Y(),2) + pow(cluster_local.Z(),2));
    gAnalyzer->GetMCTrackAt(0)->Setdrift_distanceAt(i,clus_d);
    Double_t clus_t=T(clus_d);//in ns
    Double_t sigma_elet= 1;
    Double_t sigma_diff= 1.97*sqrt(clus_d/10.)+5.9*clus_d/10.;
    t_drift= clus_t + gRandom->Gaus(0.,sigma_elet) +  gRandom->Gaus(0.,sigma_diff); 
    gAnalyzer->GetMCTrackAt(0)->Setdrift_timeAt(i,t_drift);

    if(t_drift<t_meas)
      t_meas=t_drift;
    
  }

  gAnalyzer->SetHitSize(gAnalyzer->GetHitSize()+1);//new hit
  gAnalyzer->GetHitAt(gAnalyzer->GetHitSize()-1)->Sett_meas(t_meas);

  gAnalyzer->GetHitAt(gAnalyzer->GetHitSize()-1)->Settube_nr(tube_num);


  return;

}


void GMCTMCGenerator::GenerateHits(){

  TVector3 c;
  Double_t R = gAnalyzer->GetGSP()->Gettube_radius();
  
  gAnalyzer->GetEvent()->SetTDCRefTime(0.);

  gAnalyzer->SetHitSize(0);
  gAnalyzer->SetMCHitSize(0);
  

  for(int i=1; i<=16; i++){

    TVector3 p1,p2;
    p1.SetXYZ(9999,9999,9999);
    p2.SetXYZ(9999,9999,9999);
    
    Geometry *Geom = Geometry::GetInstance();
    
    if(Intersection(Geom->Getwire_pos(i),&p1,&p2)){
      SetClustersGlobal(p1,p2,Geom->Getwire_pos(i),i); // Generate clusters &hit
    }
    
  }
  
  return;
  
}
