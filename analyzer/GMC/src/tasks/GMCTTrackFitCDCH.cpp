////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// GMCTTrackFitCDCH                                                           //
//                                                                            //
// Begin_Html <!--
/*-->

<!--*/
// --> End_Html
//                                                                            //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     GeantTrack                                                             //
//     DCHHit                                                                 //
//     SVXHit                                                                 //
//     PSHWHit                                                                //
//     RecoTracks                                                             //
//                                                                            //
// This task contains the following histgrams :                               //
//    HResidualUnbiased                                                       //
//    HResidualBiased                                                         //
//    HMomentum                                                               //
//    HPixelXres                                                              //
//    HPixelYres                                                              //
//    HPixelZres                                                              //
//                                                                            //
// The histograms/graph are created and saved automaticaly by the task.       //
//                                                                            //
// The following method can be used to get a handle of the histogram/graph :  //
//                                                                            //
// Get<Histogram/Graph Name>()                                                //
//                                                                            //
// For histogram/graph arrays use :                                           //
//                                                                            //
// Get<Histogram/Graph Name>At(Int_t index)                                   //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/GMCTTrackFitCDCHGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

//#include "util/Geometry.h"
#include "generated/GMCAnalyzer.h"
#include "generated/GMCRecoTracks.h"
#include "generated/GMCGlobalSteering.h"
#include "tasks/GMCTTrackFitCDCH.h"
#include "ROMEiostream.h"
#include "TVector3.h"
#include "TMinuit.h"
#include "TClonesArray.h"
#include "TList.h"
#include "TMath.h"
#include "TF1.h"
#include "TRandom.h"

#include "generated/GMCDCHHit.h"
#include "generated/GMCPSHWHit.h"
#include "generated/GMCGeantTrack.h"
#include "generated/GMCMPXHit.h" 

#include "CellGeometryHandle.hh"
#include "ROGeometryHandle.hh"

#include "ConstField.h"
#include "FieldManager.h"
#include <TGeoMaterialInterface.h>
#include <MaterialEffects.h>
#include "AbsTrackRep.h"
#include "RKTrackRep.h"
#include "Track.h"
#include "RectangularFinitePlane.h"
#include <Tools.h>
#include "KalmanFitter.h"
#include "KalmanFitterRefTrack.h"
#include "DAF.h"
#include "KalmanFitterInfo.h"
#include <KalmanFittedStateOnPlane.h>
#include "Exception.h"
#include "WireMeasurement.h"
#include "WirePointMeasurement.h"
#include "SpacepointMeasurement.h"
#include "PlanarMeasurement.h"

#include <TGeoGlobalMagField.h>
#include <TGeoManager.h>
#include <TROOT.h>
#include <memory>

using namespace genfit;

// uncomment if you want to include headers of all folders
//#include "GMCAllFolders.h"

extern std::ostream& operator<<( std::ostream& ostr, const TVector3& f );//{return ostr<<f.X()<<" "<<f.Y()<<" "<<f.Z();}

ClassImp(GMCTTrackFitCDCH)

using namespace std;
//______________________________________________________________________________
void GMCTTrackFitCDCH::Init() {

  fGeometry = GeometrySrvHndl::Instance();
  if(!fGeometry->GetCellHandle())
    fGeometry->makeDetectors();

  //init genfit
//  TGeoManager::Import("g4GMC.gdml");
  TGeoManager::Import(gAnalyzer->GetGSP()->GetGeomGDMLfile());
  FieldManager::getInstance()->init(new ConstField(0,0,gAnalyzer->GetGSP()->GetBz()*10.)); //kGs
  MaterialEffects* mateff=MaterialEffects::getInstance();
  //mateff->setEnergyLossBetheBloch(true);
  //mateff->setNoiseBetheBloch(true);
  //mateff->setNoiseCoulomb(true);

  //disable brems effect, as it is not correct for positron in genfit
  mateff->setEnergyLossBrems(false);
  mateff->setNoiseBrems(false);

  MaterialEffects::getInstance()->init(new TGeoMaterialInterface());
  
  //genfit::MaterialEffects::getInstance()->setNoEffects();
 
}

//______________________________________________________________________________
void GMCTTrackFitCDCH::BeginOfRun() {
}

//______________________________________________________________________________
void GMCTTrackFitCDCH::Event() {

  printf("\n GMCTTrackFitCDCH::Event ***** Load event %lld ************************ \n",gAnalyzer->GetCurrentEventNumber());

  fBrHitsSVX=gAnalyzer->GetSVXHits();
  fBrHitsPSHW=gAnalyzer->GetPSHWHits();
  fBrHitsDC=gAnalyzer->GetDCHHits();
  fBrDataTrk=gAnalyzer->GetGeantTracks();
    
  fVert = TVector3(0.,0.,0.);

  MCFinder();

  for(int i=0;i<gAnalyzer->GetRecoTracksSize();i++){
    GMCRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(i);
//    Fit(aTrk);
    Fit2(aTrk);
  }
}

void GMCTTrackFitCDCH::MCFinder(){
  int nprimary=0;
  std::vector<int> primaryID;
  primaryID.clear();
  Int_t nmctrack = fBrDataTrk->GetEntriesFast();
  for(int i=0;i<nmctrack;i++){
    GMCGeantTrack* aMCTrack = ((GMCGeantTrack*)fBrDataTrk->At(i));
    if(aMCTrack&&aMCTrack->GetfParentID()==0&&aMCTrack->GetfTrackID()>nprimary) {
      //nprimary=aMCTrack->GetfTrackID();
      primaryID.push_back(aMCTrack->GetfTrackID());
      ++nprimary;
    }
  }
  for(int i=0;i<nmctrack;i++){
    GMCGeantTrack* aMCTrack = ((GMCGeantTrack*)fBrDataTrk->At(i));
    if(aMCTrack->GetfParentID()>0&&aMCTrack->GetfTrackID()<=nprimary)
      std::cout<<"GMCTTrackFitCDCH::MCFinder: Error in logic:first tracks are not only primary "<<aMCTrack->GetfTrackID()<<" "<<nprimary<<std::endl;
  }

  Int_t nhitsdch = fBrHitsDC->GetEntriesFast();

  //sort by tof
  std::vector<std::vector<std::pair<double,int> > > hitvec(nprimary);
  for(int ihit=0;ihit<nhitsdch;ihit++){
    GMCDCHHit *ahit = (GMCDCHHit*) fBrHitsDC->At(ihit);
    //only hits beloging to primaries track
    int trkid=ahit->GetfTrkIDofHit();
    if (trkid <1 || trkid > nprimary) continue;
    hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit));
  }

  Int_t nhitssvx = fBrHitsSVX->GetEntriesFast();
  
  for(int ihit=0;ihit<nhitssvx;ihit++){
    GMCSVXHit *ahit = (GMCSVXHit*) fBrHitsSVX->At(ihit);
    //only hits beloging to primaries track
    int trkid=ahit->GetfTrkIDofHit();
    if (trkid <1 || trkid > nprimary) continue;
    hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit+nhitsdch));
  }

  Int_t nhitspshw = fBrHitsPSHW->GetEntriesFast();
  
  for(int ihit=0;ihit<nhitspshw;ihit++){
    GMCPSHWHit *ahit = (GMCPSHWHit*) fBrHitsPSHW->At(ihit);
    //only hits beloging to primaries track
    int trkid=ahit->GetfTrkIDofHit();
    if (trkid <1 || trkid > nprimary) continue;
    hitvec[trkid-1].push_back(std::pair<double,int >(ahit->GetfGlobalTime(),ihit+nhitsdch+nhitssvx));
  }

  std::cout<<"nhits dch "<<nhitsdch<<" svx "<<nhitssvx<<" pshw "<<nhitspshw<<std::endl;

  gAnalyzer->SetRecoTracksSize(nprimary);
  for(int i=0;i<nprimary;i++){
    GMCRecoTracks *aTrk = gAnalyzer->GetRecoTracksAt(i);
    aTrk->SetTrkID(primaryID.at(i));
    aTrk->Getcov()->ResizeTo(6,6);

    unsigned int ntrkhits=hitvec[i].size();
    aTrk->Setnhits(ntrkhits);
    aTrk->SethitindexSize(ntrkhits);
    aTrk->SetdetidSize(ntrkhits);
    aTrk->SetIsFitted(false);
    aTrk->Getcov()->ResizeTo(6,6);

    //sort by tof
    std::sort(hitvec[i].begin(),hitvec[i].end());

    for(unsigned int ihit=0;ihit<ntrkhits;ihit++){
      int detid=hitvec[i][ihit].second<nhitsdch?0:(hitvec[i][ihit].second<nhitsdch+nhitssvx?1:2);
      aTrk->SetdetidAt(ihit,detid);
      aTrk->SethitindexAt(ihit,hitvec[i][ihit].second-(detid>0?nhitsdch:0)-(detid>1?nhitssvx:0));
    }


    //fit only first turn
    double trkdir_prev=1.;
    for(unsigned int ihit=0;ihit<ntrkhits;ihit++){

      TVector3 xyz,k;
      int detid=hitvec[i][ihit].second<nhitsdch?0:(hitvec[i][ihit].second<nhitsdch+nhitssvx?1:2);

      if(detid==0){
        GMCDCHHit *aHit = (GMCDCHHit*) fBrHitsDC->At(hitvec[i][ihit].second);
 
        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());
      }else if(detid==1){
        GMCSVXHit *aHit = (GMCSVXHit*) fBrHitsSVX->At(hitvec[i][ihit].second-nhitsdch);
 
        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());        
      }else{
        GMCPSHWHit *aHit = (GMCPSHWHit*) fBrHitsPSHW->At(hitvec[i][ihit].second-nhitsdch-nhitssvx);
 
        xyz=TVector3(aHit->GetfEntranceX(),aHit->GetfEntranceY(),0);//aHit->GetfEntranceZ());
        k=TVector3(aHit->GetfEntranceMomX(),aHit->GetfEntranceMomY(),0);//aHit->GetfEntranceMomZ());        
      }
      
      double trkdir=xyz.Dot(k)/xyz.Mag()/k.Mag();
      if(trkdir_prev<=0&&trkdir>0){
        aTrk->Setnhits(ihit-1);
        break;
      }
      trkdir_prev=trkdir;
    }
  }

}


//______________________________________________________________________________
void GMCTTrackFitCDCH::StoreReconstructedTrack() {
}

//______________________________________________________________________________
void GMCTTrackFitCDCH::EndOfRun()
{
}
//______________________________________________________________________________
void GMCTTrackFitCDCH::Terminate() {
}

//______________________________________________________________________________
Bool_t GMCTTrackFitCDCH::Fit(GMCRecoTracks *aTrack) {
  int fDebug=GetSP()->GetDebugLevel();//1;
  

  int nhits = aTrack->Getnhits();

  if (nhits < 6) {
    printf(" ****  !!! Event not reconstructable: number of hits forr signal track less than 6!\n");
    return false;
  }

  int trkid=0;
  TVector3 xyzhit0,momhit0;
  if(aTrack->GetdetidAt(0)==0){
    GMCDCHHit *ahit0 = (GMCDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(0));
    xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();
  }else if(aTrack->GetdetidAt(0)==1){
    GMCSVXHit *ahit0 = (GMCSVXHit*) fBrHitsSVX->At(aTrack->GethitindexAt(0));
    xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();
  }else{
    GMCPSHWHit *ahit0 = (GMCPSHWHit*) fBrHitsPSHW->At(aTrack->GethitindexAt(0));
    xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();
  }

  //init values
  TVector3 xyz0=xyzhit0;//fVert;
  TVector3 pdir0=momhit0;
  pdir0.SetMag(1.);
  TVector3 pmom0=momhit0;//

  //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
  TMatrixDSym Cov(6); Cov.Zero();

  Cov[0][0] = Cov[1][1] =Cov[2][2] = 0.1*0.1;//centimeters
  Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

  //-----------------------------------
  //init positron track with parameters from first State Vector and predefined Covariance matrix
  //-----------------------------------
  int pdgid=11;
  if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
    for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
      GMCGeantTrack* aMCTrack = ((GMCGeantTrack*)fBrDataTrk->At(i));
      if(aMCTrack->GetfTrackID()==trkid){
        pdgid=aMCTrack->GetfPDGCode();
        if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
        break;
      }
    }
  }

  //
  if(fDebug) 
    std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
  AbsTrackRep *rep = new RKTrackRep(pdgid);
  MeasuredStateOnPlane stateRef(rep);
  rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
  stateRef.setTime(0.);

  //init genfit track from initial state
  TVectorD seedState(6);
  TMatrixDSym seedCov(6);
  rep->get6DStateCov(stateRef, seedState, seedCov);
  Track fitTrack(rep,seedState, seedCov);
  fitTrack.setTimeSeed(0.);


  //-----------------------------------------------
  //fill hit information
  //-----------------------------------------------
  int nid=0;

  //add vertex constrain
  double sigmabeam=GetSP()->GetSigmaVtx();
  if(sigmabeam>0){
    TVectorD hitCoords(3);
    TMatrixDSym hitCov(3);
    for(int i=0;i<3;i++)
      hitCoords(i)=gRandom->Gaus()*sigmabeam;
    hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam; 
    genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
    fitTrack.insertMeasurement(measurement,nid++);
    if(fDebug)
      cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
  }

  int ihit0dch=-1,ihit0svx=-1,ihit0pshw=-1;
  int nhitsdch=0,nhitssvx=0,nhitspshw=0;
  
  for(int ihit=0;ihit<nhits;ihit++){

    if(aTrack->GetdetidAt(ihit)==0){
      if(ihit0dch<0) ihit0dch=0;
      nhitsdch++;
      GMCDCHHit *ahit =(GMCDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
      
      Int_t nwire=ahit->GetfCellId();
      
      fGeometry->GetCellHandle()->SelectCellDet(nwire);
      const CLHEP::Hep3Vector& mid   = fGeometry->GetCellHandle()->GetCellCenter();
      const CLHEP::Hep3Vector& w     = fGeometry->GetCellHandle()->GetCellDirection();
      
      TVector3 wire_pos(mid.x(),mid.y(),mid.z());
      TVector3 wire_dir(w.x(),w.y(),w.z());

      Double_t b_meas = ahit->GetfImpact();
      
      //fill mesuarements
      TVector3 p0 = 0.1*wire_pos;
      TVector3 w_axis = wire_dir;
      double wnorm=w_axis.Mag();
      TVectorD hitCoords(8);
      TMatrixDSym hitCov(8);
      //fill wire ends
      for(int i=0;i<3;i++){
        hitCoords(i)=(p0+100*w_axis)(i);
        hitCoords(i+3)=(p0-100*w_axis)(i);
      }
      //mesuared values dist,Z:
      double sigmab=GetSP()->GetSigmaRPhi();
      hitCoords(6) = b_meas*0.1+gRandom->Gaus()*sigmab;
      //z mesuarment are relative to wire1 in direction of wire2
      hitCoords(7) = 100.*wnorm;
      hitCov(6,6) = sigmab*sigmab;
      hitCov(7,7) = 100*100;
      WireMeasurement *whit;
      if(1==0){//use Z 
        whit=new WirePointMeasurement(hitCoords, hitCov,0,ihit,nullptr);
      }else{
        whit=new WireMeasurement(hitCoords, hitCov,0,ihit,nullptr);
      }
      whit->setLeftRightResolution(0);//1>0?1:-1);
      fitTrack.insertMeasurement(whit,nid++);
      
      if(fDebug>1){
        std::cout<<"add "<<ihit<<" wire "<<nwire<<" xywire "<<p0.X()<<" "<<p0.Y()<<" "<<p0.z()
	         <<" bl "<<hitCoords(6)<<" sigma "<<sqrt(hitCov(6,6))<<" "<<sqrt(hitCov(7,7))<<" xyz "
	         <<0.1*ahit->GetfEntranceX()<<" "<<0.1*ahit->GetfEntranceY()<<" "<<0.1*ahit->GetfEntranceZ()<<" T "<<ahit->GetfGlobalTime()<<std::endl;
      }
    }else if(aTrack->GetdetidAt(ihit)==1){
      if(ihit0svx<0) ihit0svx=0;
      nhitssvx++;
      GMCSVXHit *ahit =(GMCSVXHit*) fBrHitsSVX->At(aTrack->GethitindexAt(ihit));

      double pxlResolution=GetSP()->GetSigmaPxlVtx();
      //double pxlResolution=GetSP()->GetSigmaPxlPreshower();
      TMatrixDSym hitpxlCov(2);
      hitpxlCov.UnitMatrix();
      hitpxlCov *= pxlResolution*pxlResolution;

      TVector3 pixel(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
      TVectorD hitCoords(2);
      hitCoords[0] = gRandom->Gaus()*pxlResolution;
      hitCoords[1] = gRandom->Gaus()*pxlResolution;
      genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 1, ihit, nullptr);
      TVector3 vdir(-pixel.Y(),pixel.X(),0);vdir.SetMag(1);
      measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(TVector3(pixel.X(),pixel.Y(),pixel.Z()), vdir, TVector3(0,0,1))), 0);
      fitTrack.insertMeasurement(measurement,nid++);
      if(fDebug>1) {
        cout<<" add "<<ihit<<" VTX mes "<<hitCoords[0]<<" "<<hitCoords[1]
            <<" xyz "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<< " with +- "<<pxlResolution<<" T "<<ahit->GetfGlobalTime()<<endl;
        cout<<"U dir: "; vdir.Print();
        cout<<"V dir: "; TVector3(0,0,1).Print();
      }
    }else{
      if(ihit0svx<0) ihit0svx=0;
      nhitspshw++;
      GMCPSHWHit *ahit =(GMCPSHWHit*) fBrHitsPSHW->At(aTrack->GethitindexAt(ihit));

      //double pxlResolution=GetSP()->GetSigmaPxlVtx();
      double pxlResolution=GetSP()->GetSigmaPxlPreshower();
      TMatrixDSym hitpxlCov(2);
      hitpxlCov.UnitMatrix();
      hitpxlCov *= pxlResolution*pxlResolution;

      TVector3 pixel(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
      TVectorD hitCoords(2);
      hitCoords[0] = gRandom->Gaus()*pxlResolution;
      hitCoords[1] = gRandom->Gaus()*pxlResolution;
      genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 2, ihit, nullptr);
      TVector3 vdir(-pixel.Y(),pixel.X(),0);vdir.SetMag(1);
      measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(TVector3(pixel.X(),pixel.Y(),pixel.Z()), vdir, TVector3(0,0,1))), 0);
      fitTrack.insertMeasurement(measurement,nid++);
      if(fDebug>1)
        cout<<" add "<<ihit<<" PSHW mes "<<hitCoords[0]<<" "<<hitCoords[1]
            <<" xyz "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<< " with +- "<<pxlResolution<<" T "<<ahit->GetfGlobalTime()<<endl;

    }
  }


  
  // ---- end of hit info filling ------------------------

  
  assert(fitTrack.checkConsistency());
  genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
  if(fDebug){
    std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
             <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
	     <<" nhits "<<nid<<" from "<<nhits<<" dch "<<nhitsdch<<" svx "<<nhitssvx<<" pshw "<<nhitspshw<<std::endl;
    std::cout<<"init state "<<xyz0<<" "<<pmom0<<endl;
  }

  //choose different fitter
  genfit::AbsKalmanFitter* fitter = 0;
  switch(0/*GetSP()->GetKalmanType()*/){
  case 0:
    fitter=new DAF();
    break;
  case 1:
    fitter=new KalmanFitterRefTrack(20);
    break;
  case 2:
    fitter=new KalmanFitter(20);
    break;
  }
  /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter 
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/
  
  if(kDebug>20){
    fitter->setDebugLvl(10);
    rep->setDebugLvl(10);
  }

  //-----------------------------------
  // FIT IT
  //-----------------------------------
  //cout<<"-----------1-------------"<<endl;
  try{
    fitter->processTrack(&fitTrack);
  }catch(Exception& e){
    if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
  }
  //cout<<"-----------2-------------"<<endl;
  fitStatus=fitTrack.getFitStatus(rep);
  bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
  if(fDebug) fitStatus->Print();
  //cout<<"-----------3-------------"<<endl;


  TVector3 pos,mom;
  TMatrixDSym cov(6);
  TVector3 pos2,mom2;
  TMatrixDSym cov2(6);
  double pmom=0;
  double tof=0;
  double sigmap=0.;

  //-----------------------------------
  // fill info from first hit  
  //-----------------------------------

  try{
    const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
    pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
    stFirst.getPosMomCov(pos,mom,cov);
    tof=stFirst.getTime();
  }catch(Exception& e){
    if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
  }


  if(fDebug)
    std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
             <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;
  
  if(fDebug){std::cout<<"fitted xyz "<<pos<<" mom "<<mom<<endl;}

  //-----------------------------------
  //set states on hits
  //-----------------------------------

  unsigned int numhits = fitTrack.getNumPoints();

  int ngoodhits=0;
  int ngoodhitsdch=0,ngoodhitssvx=0,ngoodhitspshw=0;
  double sumddist=0;

  aTrack->SetStateVectorSize(nhits);
  aTrack->GetSkipped().resize(nhits,true);
  
  if(fitstatus){
    try{
      for(unsigned int jhit=0;jhit<numhits;jhit++){
        TrackPoint* point = fitTrack.getPoint(jhit);
        int ihit=point->getRawMeasurement(0)->getHitId();
        int detid=point->getRawMeasurement(0)->getDetId();
        //skip virtual hit
	//        if(ihit>=1000) continue;
	
        //skip point without fitted information
        if(!point->hasFitterInfo(rep)) continue;
        
        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
        //get weights for LR combinations
        std::vector<double> dafWeights = fi->getWeights();

        //maximum weigth in fitting from LR positions 
        int imaxdaf=std::distance(dafWeights.begin(),
                                  std::max_element(dafWeights.begin(),dafWeights.end()));
        double maxdaf=dafWeights[imaxdaf];


	//fill histogram with final chi2 per hit
	const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
	const TVectorD& resid(residual.getState());

        //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
        if(maxdaf<0.5) {
          if(fDebug>9) std::cout<<"skip point "<<endl;
          continue;
        }
	
        //fill biased best StateVector on hit
        // (averaged from forward-backward propagation)
	const MeasuredStateOnPlane& state=fi->getFittedState(true);  
	state.getPosMomCov(pos,mom,cov);

	//unbiased
	const MeasuredStateOnPlane& state2=fi->getFittedState(false);  
	state2.getPosMomCov(pos2,mom2,cov2);
      	
	if(detid==0){
	  //average T0 shift over hits
	  sumddist+=resid(0)*(imaxdaf?1:-1);
          ngoodhitsdch++;
        }else if(detid==1){
          ngoodhitssvx++;
        }else if(detid==2){
          ngoodhitspshw++;
        }
        
	if(detid<10){ //wire or svx or pshw hit
	  aTrack->SetSkippedAt(ihit,false);
          *aTrack->GetStateVectorAt(ihit)=pos;
	  ngoodhits++;
          if(detid==0){
            GMCDCHHit *ahit = (GMCDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
            if(fDebug>9)
              cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" mes "<<0.1*ahit->GetfImpact()<<" dR not biased "<<resid(0)
                  <<" biased "<<0.1*ahit->GetfImpact()-fabs(state.getState()(3))<<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
            GetHResidualUnbiased()->Fill(10*fabs(state.getState()(3)),10*resid(0));
            GetHResidualBiased()->Fill(10*fabs(state.getState()(3)),ahit->GetfImpact()-10*fabs(state.getState()(3)));
          }else if(detid==1){
            GMCSVXHit *ahit = (GMCSVXHit*) fBrHitsSVX->At(aTrack->GethitindexAt(ihit));
            if(fDebug>9)
              cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                  <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
          }else if(detid==2){
            GMCPSHWHit *ahit = (GMCPSHWHit*) fBrHitsPSHW->At(aTrack->GethitindexAt(ihit));
            if(fDebug>9)
              cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                  <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
          }
	}
	// state.Print();
	// cov.Print();
	// state2.Print();
	// cov2.Print();
        if(ihit==aTrack->GethitindexAt(0)) 
          if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
	if(fDebug>9) {
          std::cout<<jhit<<" detid "<<detid<<" id "<<ihit<<" at hit "<<pos<<" "<<mom<<endl;
        }
      }
    }catch(Exception& e){
      if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
      fitstatus=false;
    }
    sumddist/=ngoodhitsdch;
    if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits<<" average ddist "<<sumddist/(0.4/150e-9)<<std::endl;
  }
  
  
  //-----------------------------------
  //propagate to target
  //-----------------------------------
  if(fitstatus){

    //force backward propagation(will be working forr only finite plane
    rep->setPropDir(-1);
    //take first fitted point
    TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
    if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
    KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
    MeasuredStateOnPlane state;

    //extrapolate rep to target plane
    bool isattarget=true;
    try{
      state=fi->getFittedState(true);
      rep->extrapolateToLine(state,TVector3(0,0,0),TVector3(0,0,1));
    }catch(Exception& e){
      if(fDebug) std::cout<<"on extrapolation to beam line "<<e.what()<<std::endl;
      isattarget=false;
    }
    double tof_target=1e9;
    if(isattarget){
      tof_target=state.getTime();    
      state.getPosMomCov(pos,mom,cov);
      double momrec=mom.Mag();
      sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

    }
    if(fDebug)
      std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
	       <<" nhits "<<nhits<<" dch "<<nhitsdch<<" svx "<<nhitssvx<<" pshw "<<nhitspshw<<" nfailed "<<fitStatus->getNFailedPoints()
               <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
	       <<" pos "<<pos<<" mom "<<mom<<std::endl;
  }

  aTrack->Setx0(pos.X()*10);
  aTrack->Seterr_x0(sqrt(cov(0,0))*10);
  aTrack->Sety0(pos.Y()*10);
  aTrack->Seterr_y0(sqrt(cov(1,1))*10);
  aTrack->Setz0(pos.Z()*10);
  aTrack->Seterr_z0(sqrt(cov(2,2))*10);
  aTrack->Settheta(mom.Theta());
  aTrack->Seterr_theta(0.);
  aTrack->Setphi(mom.Phi());
  aTrack->Seterr_phi(0.);
  aTrack->SetMomentum(mom.Mag());
  aTrack->SetErr_Momentum(sigmap);
  aTrack->Setmom(mom);
  aTrack->Getcov()->ResizeTo(6,6);
  aTrack->Setcov(cov);
  
  //fill final information
  aTrack->Setnhits(nhits);
  aTrack->Setnhitsdch(nhitsdch);
  aTrack->Setnhitssvx(nhitssvx);
  aTrack->Setnhitspshw(nhitspshw);
  aTrack->Setchi2(fitStatus->getChi2());
  aTrack->Setdof(fitStatus->getNdf());
  aTrack->Setngoodhits(ngoodhits);
  aTrack->Setngoodhitsdch(ngoodhitsdch);
  aTrack->Setngoodhitssvx(ngoodhitssvx);
  aTrack->Setngoodhitspshw(ngoodhitspshw);
  aTrack->SetIsFitted(fitstatus);
  
  
  delete fitter;

  return true;
}

//______________________________________________________________________________
Bool_t GMCTTrackFitCDCH::Fit2(GMCRecoTracks *aTrack) {
  int fDebug=GetSP()->GetDebugLevel();//1;


  int nhits = aTrack->Getnhits();

  if (nhits < 6) {
    printf(" ****  !!! Event not reconstructable: number of hits forr signal track less than 6!\n");
    return false;
  }

  int trkid=0;
  TVector3 xyzhit0,momhit0;
  if(aTrack->GetdetidAt(0)==0){
    GMCDCHHit *ahit0 = (GMCDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(0));
    xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();
  }else if(aTrack->GetdetidAt(0)==1){
    GMCSVXHit *ahit0 = (GMCSVXHit*) fBrHitsSVX->At(aTrack->GethitindexAt(0));
    xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();
  }else{
    GMCPSHWHit *ahit0 = (GMCPSHWHit*) fBrHitsPSHW->At(aTrack->GethitindexAt(0));
    xyzhit0=0.1*TVector3(ahit0->GetfEntranceX(),ahit0->GetfEntranceY(),ahit0->GetfEntranceZ()); // mm -> cm
    momhit0=0.001*TVector3(ahit0->GetfEntranceMomX(),ahit0->GetfEntranceMomY(),ahit0->GetfEntranceMomZ()); // MeV -> GeV
    trkid=ahit0->GetfTrkIDofHit();
  }

  //init values
  TVector3 xyz0=xyzhit0;//fVert;
  TVector3 pdir0=momhit0;
  pdir0.SetMag(1.);
  TVector3 pmom0=momhit0;//

  //Do initialization of initial covariance matrix with sigma_p,sigma_angle, 1cm position
  TMatrixDSym Cov(6); Cov.Zero();

  Cov[0][0] = Cov[1][1] =Cov[2][2] = 0.1*0.1;//centimeters
  Cov[3][3] = Cov[4][4] =Cov[5][5] = 0.001*0.001;//GeV

  //-----------------------------------
  //init positron track with parameters from first State Vector and predefined Covariance matrix
  //-----------------------------------
  int pdgid=11;
  if(trkid<=fBrDataTrk->GetEntriesFast()&&trkid>0){
    for(int i=0;i<fBrDataTrk->GetEntriesFast();i++){
      GMCGeantTrack* aMCTrack = ((GMCGeantTrack*)fBrDataTrk->At(i));
      if(aMCTrack->GetfTrackID()==trkid){
        pdgid=aMCTrack->GetfPDGCode();
        if(fDebug) std::cout<<"Primary track n. "<<i<<" has different PDG "<<pdgid<<std::endl;
        break;
      }
    }
  }

  //
  if(fDebug)
    std::cout<<"set charge to pdgid ="<<pdgid<<std::endl;
  AbsTrackRep *rep = new RKTrackRep(pdgid);
  MeasuredStateOnPlane stateRef(rep);
  rep->setPosMomCov(stateRef,xyz0,pmom0,Cov);
  stateRef.setTime(0.);

  //init genfit track from initial state
  TVectorD seedState(6);
  TMatrixDSym seedCov(6);
  rep->get6DStateCov(stateRef, seedState, seedCov);
  Track fitTrack(rep,seedState, seedCov);
  fitTrack.setTimeSeed(0.);


  //-----------------------------------------------
  //fill hit information
  //-----------------------------------------------
  int nid=0;

  //add vertex constrain
  double sigmabeam=GetSP()->GetSigmaVtx();
  if(sigmabeam>0){
    TVectorD hitCoords(3);
    TMatrixDSym hitCov(3);
    for(int i=0;i<3;i++)
      hitCoords(i)=gRandom->Gaus()*sigmabeam;
    hitCov(0,0) = hitCov(1,1) = hitCov(2,2) = sigmabeam*sigmabeam;
    genfit::SpacepointMeasurement* measurement = new genfit::SpacepointMeasurement(hitCoords, hitCov, 10, 100000, NULL);
    fitTrack.insertMeasurement(measurement,nid++);
    if(fDebug)
      cout<<" add vertex constrain " <<hitCoords(0)<<" "<<hitCoords(1)<<" "<<hitCoords(2)<< " with +- "<<sigmabeam<<endl;
  }

  int ihit0dch=-1,ihit0svx=-1,ihit0pshw=-1;
  int nhitsdch=0,nhitssvx=0,nhitspshw=0;

  for(int ihit=0;ihit<nhits;ihit++){

    if(aTrack->GetdetidAt(ihit)==0){
      if(ihit0dch<0) ihit0dch=0;
      nhitsdch++;
      GMCDCHHit *ahit =(GMCDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));

      Int_t nwire=ahit->GetfCellId();

      fGeometry->GetCellHandle()->SelectCellDet(nwire);
      const CLHEP::Hep3Vector& mid   = fGeometry->GetCellHandle()->GetCellCenter();
      const CLHEP::Hep3Vector& w     = fGeometry->GetCellHandle()->GetCellDirection();

      TVector3 wire_pos(mid.x(),mid.y(),mid.z());
      TVector3 wire_dir(w.x(),w.y(),w.z());

      Double_t b_meas = ahit->GetfImpact();

      //fill mesuarements
      TVector3 p0 = 0.1*wire_pos;
      TVector3 w_axis = wire_dir;
      double wnorm=w_axis.Mag();
      TVectorD hitCoords(8);
      TMatrixDSym hitCov(8);
      //fill wire ends
      for(int i=0;i<3;i++){
        hitCoords(i)=(p0+100*w_axis)(i);
        hitCoords(i+3)=(p0-100*w_axis)(i);
      }
      //mesuared values dist,Z:
      double sigmab=GetSP()->GetSigmaRPhi();
      hitCoords(6) = b_meas*0.1+gRandom->Gaus()*sigmab;
      //z mesuarment are relative to wire1 in direction of wire2
      hitCoords(7) = 100.*wnorm;
      hitCov(6,6) = sigmab*sigmab;
      hitCov(7,7) = 100*100;
      WireMeasurement *whit;
      if(1==0){//use Z
        whit=new WirePointMeasurement(hitCoords, hitCov,0,ihit,nullptr);
      }else{
        whit=new WireMeasurement(hitCoords, hitCov,0,ihit,nullptr);
      }
      whit->setLeftRightResolution(0);//1>0?1:-1);
      fitTrack.insertMeasurement(whit,nid++);

      if(fDebug>1){
        std::cout<<"add "<<ihit<<" wire "<<nwire<<" xywire "<<p0.X()<<" "<<p0.Y()<<" "<<p0.z()
             <<" bl "<<hitCoords(6)<<" sigma "<<sqrt(hitCov(6,6))<<" "<<sqrt(hitCov(7,7))<<" xyz "
             <<0.1*ahit->GetfEntranceX()<<" "<<0.1*ahit->GetfEntranceY()<<" "<<0.1*ahit->GetfEntranceZ()<<" T "<<ahit->GetfGlobalTime()<<std::endl;
      }
    }else if(aTrack->GetdetidAt(ihit)==1){
      if(ihit0svx<0) ihit0svx=0;
      nhitssvx++;
      GMCSVXHit *ahit =(GMCSVXHit*) fBrHitsSVX->At(aTrack->GethitindexAt(ihit));

      unsigned long nRO = ahit->GetfChanId();
      fGeometry->GetROChanHandle()->SelectRODet(nRO);
      bool isFw = fGeometry->GetROChanHandle()->isFwLayer();
      double pxlResolution=round(fGeometry->GetROChanHandle()->GetROChanFstSdDim()*2886.751345948)*1e-5;  //1e+4*1/sqrt(12)=2886.751345948  , 1e-4*0.1 for mm -> cm
      double pxlResolutionSndSd=round(fGeometry->GetROChanHandle()->GetROChanSndSdDim()*2886.751345948)*1e-5;
//      cout<<"Resols "<<pxlResolution<<" "<<pxlResolutionSndSd<<endl;
      TMatrixDSym hitpxlCov(2);
      hitpxlCov.UnitMatrix();
      hitpxlCov *= pxlResolution*pxlResolutionSndSd;

      const CLHEP::Hep3Vector& lclmid   = fGeometry->GetROChanHandle()->GetROChanCenterLcl();

      TVectorD hitCoords(2);
      hitCoords[0] = 0.1*lclmid.x();
      hitCoords[1] = 0.1*lclmid.z();
      genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 1, ihit, nullptr);

      const CLHEP::Hep3Vector& ldmid   = fGeometry->GetROChanHandle()->GetROLayerMidPoint();
      const CLHEP::Hep3Vector& ldFstSdDir   = fGeometry->GetROChanHandle()->GetLadderFstSdDir();
      const CLHEP::Hep3Vector& ldSndSdDir   = fGeometry->GetROChanHandle()->GetLadderSndSdDir();
      TVector3 ldMid(0.1*ldmid.x(),0.1*ldmid.y(),0.1*ldmid.z());
      TVector3 udir(ldFstSdDir.x(),ldFstSdDir.y(),ldFstSdDir.z());
      TVector3 vdir(ldSndSdDir.x(),ldSndSdDir.y(),ldSndSdDir.z());

      measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(ldMid, udir, vdir)), 0);//0 could be ihit as in the example
      fitTrack.insertMeasurement(measurement,nid++);
      if (fDebug==-1) {
    	  const CLHEP::Hep3Vector& glbmid = fGeometry->GetROChanHandle()->GetROChanCenterGbl();
    	  TVector3 pixel(0.1*glbmid.x(),0.1*glbmid.y(),0.1*glbmid.z());
    	  TVector3 hitPnt(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
    	  TVector3 pixelM(ldMid.x()+hitCoords[0]*udir.x()+hitCoords[1]*vdir.x(),
    			  ldMid.y()+hitCoords[0]*udir.y()+hitCoords[1]*vdir.y(),
				  ldMid.z()+hitCoords[0]*udir.z()+hitCoords[1]*vdir.z());
    	  GetHPixelXres()->Fill((pixelM-hitPnt).X(),fGeometry->GetROChanHandle()->GetLayerId());
    	  GetHPixelYres()->Fill((pixelM-hitPnt).Y(),fGeometry->GetROChanHandle()->GetLayerId());
    	  GetHPixelZres()->Fill((pixelM-hitPnt).Z(),fGeometry->GetROChanHandle()->GetLayerId());
      }
      if(fDebug>1) {
        const CLHEP::Hep3Vector& glbmid = fGeometry->GetROChanHandle()->GetROChanCenterGbl();
        TVector3 pixel(0.1*glbmid.x(),0.1*glbmid.y(),0.1*glbmid.z());
        TVector3 hitPnt(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
        TVector3 pixelM(ldMid.x()+hitCoords[0]*udir.x()+hitCoords[1]*vdir.x(),
                        ldMid.y()+hitCoords[0]*udir.y()+hitCoords[1]*vdir.y(),
                        ldMid.z()+hitCoords[0]*udir.z()+hitCoords[1]*vdir.z());
        cout<<" add "<<ihit<<" VTX mes in Sec "<< fGeometry->GetROChanHandle()->GetPhiSecId()
                                      <<" lay "<< fGeometry->GetROChanHandle()->GetLayerId()
                                      <<" lad "<< fGeometry->GetROChanHandle()->GetLadderId()
                                      <<" is Fw "<<isFw
                                      <<" pos: "<<hitCoords[0]<<" "<<hitCoords[1]<<endl;
        cout<<" xyz "<<hitPnt.X()<<" "<<hitPnt.Y()<<" "<<hitPnt.Z()<< " with +- "<<pxlResolution<< " with +- "<<pxlResolutionSndSd<<" T "<<ahit->GetfGlobalTime()<<endl;

        cout<<"  M  "<<pixelM.X()<<" "<<pixelM.Y()<<" "<<pixelM.Z()<<" dist "<<(pixelM-hitPnt).Mag()<<endl;
        cout<<"  P  "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<<" dist "<<(pixel-hitPnt).Mag()<<endl;

        cout<<"Ld mid: "; ldMid.Print();
        cout<<"U dir: "; udir.Print();
        cout<<"V dir: "; vdir.Print();
      }

    }else{
      if(ihit0svx<0) ihit0svx=0;
      nhitspshw++;
      GMCSVXHit *ahit =(GMCSVXHit*) fBrHitsPSHW->At(aTrack->GethitindexAt(ihit));

      unsigned long nRO = ahit->GetfChanId();
      fGeometry->GetPSHWROChanHandle()->SelectRODet(nRO);
      bool isFw = fGeometry->GetPSHWROChanHandle()->isFwLayer();

      double pxlResolution=round(fGeometry->GetPSHWROChanHandle()->GetROChanFstSdDim()*2886.751345948)*1e-5;  //1e+4*1/sqrt(12)=2886.751345948  , 1e-4*0.1 for mm -> cm
      double pxlResolutionSndSd=round(fGeometry->GetPSHWROChanHandle()->GetROChanSndSdDim()*2886.751345948)*1e-5;
      TMatrixDSym hitpxlCov(2);
      hitpxlCov.UnitMatrix();
      hitpxlCov *= pxlResolution*pxlResolutionSndSd;

      const CLHEP::Hep3Vector& lclmid   = fGeometry->GetPSHWROChanHandle()->GetROChanCenterLcl();

      TVectorD hitCoords(2);
      hitCoords[0] = 0.1*lclmid.x();
      hitCoords[1] = 0.1*lclmid.z();
      genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(hitCoords, hitpxlCov, 2, ihit, nullptr);

      const CLHEP::Hep3Vector& ldmid   = fGeometry->GetPSHWROChanHandle()->GetROLayerMidPoint();
      const CLHEP::Hep3Vector& ldFstSdDir   = fGeometry->GetPSHWROChanHandle()->GetLadderFstSdDir();
      const CLHEP::Hep3Vector& ldSndSdDir   = fGeometry->GetPSHWROChanHandle()->GetLadderSndSdDir();
      TVector3 ldMid(0.1*ldmid.x(),0.1*ldmid.y(),0.1*ldmid.z());
      TVector3 udir(ldFstSdDir.x(),ldFstSdDir.y(),ldFstSdDir.z());
      TVector3 vdir(ldSndSdDir.x(),ldSndSdDir.y(),ldSndSdDir.z());

      measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(ldMid, udir, vdir)), 0);
      fitTrack.insertMeasurement(measurement,nid++);
      if(fDebug>1) {
        const CLHEP::Hep3Vector& glbmid = fGeometry->GetPSHWROChanHandle()->GetROChanCenterGbl();
        TVector3 pixel(0.1*glbmid.x(),0.1*glbmid.y(),0.1*glbmid.z());
        TVector3 hitPnt(0.1*ahit->GetfEntranceX(),0.1*ahit->GetfEntranceY(),0.1*ahit->GetfEntranceZ());
        TVector3 pixelM(ldMid.x()+hitCoords[0]*udir.x()+hitCoords[1]*vdir.x(),
                        ldMid.y()+hitCoords[0]*udir.y()+hitCoords[1]*vdir.y(),
                        ldMid.z()+hitCoords[0]*udir.z()+hitCoords[1]*vdir.z());
        cout<<" add "<<ihit<<" PSHW mes in Sec "<< fGeometry->GetPSHWROChanHandle()->GetPhiSecId()
                                      <<" lay "<< fGeometry->GetPSHWROChanHandle()->GetLayerId()
                                      <<" lad "<< fGeometry->GetPSHWROChanHandle()->GetLadderId()
                                      <<" is Fw "<<isFw
                                      <<" pos: "<<hitCoords[0]<<" "<<hitCoords[1]<<endl;
        cout<<" xyz "<<hitPnt.X()<<" "<<hitPnt.Y()<<" "<<hitPnt.Z()<< " with +- "<<pxlResolution<< " with +- "<<pxlResolutionSndSd<<" T "<<ahit->GetfGlobalTime()<<endl;

        cout<<"  M  "<<pixelM.X()<<" "<<pixelM.Y()<<" "<<pixelM.Z()<<" dist "<<(pixelM-hitPnt).Mag()<<endl;
        cout<<"  P  "<<pixel.X()<<" "<<pixel.Y()<<" "<<pixel.Z()<<" dist "<<(pixel-hitPnt).Mag()<<endl;

        cout<<"Ld mid: "; ldMid.Print();
        cout<<"U dir: "; udir.Print();
        cout<<"V dir: "; vdir.Print();
      }

    }
  }



  // ---- end of hit info filling ------------------------


  assert(fitTrack.checkConsistency());
  genfit::FitStatus* fitStatus=fitTrack.getFitStatus(rep);
  if(fDebug){
    std::cout<<" init chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
             <<" P= "<<rep->getMomMag(stateRef)*rep->getCharge(stateRef)<<" +- "<<sqrt(rep->getMomVar(stateRef))
         <<" nhits "<<nid<<" from "<<nhits<<" dch "<<nhitsdch<<" svx "<<nhitssvx<<" pshw "<<nhitspshw<<std::endl;
    std::cout<<"init state "<<xyz0<<" "<<pmom0<<endl;
  }

  //choose different fitter
  genfit::AbsKalmanFitter* fitter = 0;
  switch(0/*GetSP()->GetKalmanType()*/){
  case 0:
    fitter=new DAF();
    break;
  case 1:
    fitter=new KalmanFitterRefTrack(20);
    break;
  case 2:
    fitter=new KalmanFitter(20);
    break;
  }
  /*
  if(GetSP()->GetKalmanType()>0){
    //use LR from patter recognition in case of usual KalmanFitter
    fitter->setMultipleMeasurementHandling(genfit::weightedClosestToPredictionWire);
  }*/

  if(kDebug>20){
    fitter->setDebugLvl(10);
    rep->setDebugLvl(10);
  }

  //-----------------------------------
  // FIT IT
  //-----------------------------------

  try{
    fitter->processTrack(&fitTrack);
  }catch(Exception& e){
    if(fDebug) std::cout<<"on fitting "<<e.what()<<std::endl;
  }
  fitStatus=fitTrack.getFitStatus(rep);
  bool fitstatus=fitStatus->isFitConverged()&&(fitStatus->getNFailedPoints()==0);
  if(fDebug) fitStatus->Print();


  TVector3 pos,mom;
  TMatrixDSym cov(6);
  TVector3 pos2,mom2;
  TMatrixDSym cov2(6);
  double pmom=0;
  double tof=0;
  double sigmap=0.;

  //-----------------------------------
  // fill info from first hit
  //-----------------------------------

  try{
    const MeasuredStateOnPlane& stFirst=fitTrack.getFittedState();
    pmom=rep->getMomMag(stFirst)*rep->getCharge(stFirst);
    stFirst.getPosMomCov(pos,mom,cov);
    tof=stFirst.getTime();
  }catch(Exception& e){
    if(fDebug) std::cout<<"on getting state "<<e.what()<<std::endl;
  }


  if(fDebug)
    std::cout<<" chi2 "<<fitStatus->getChi2()<<" nfailed "<<fitStatus->getNFailedPoints()
             <<" P= "<<pmom<<" fitok="<<fitstatus<<std::endl;

  if(fDebug){std::cout<<"fitted xyz "<<pos<<" mom "<<mom<<endl;}

  //-----------------------------------
  //set states on hits
  //-----------------------------------

  unsigned int numhits = fitTrack.getNumPoints();

  int ngoodhits=0;
  int ngoodhitsdch=0,ngoodhitssvx=0,ngoodhitspshw=0;
  double sumddist=0;

  aTrack->SetStateVectorSize(nhits);
  aTrack->GetSkipped().resize(nhits,true);

  if(fitstatus){
    try{
      for(unsigned int jhit=0;jhit<numhits;jhit++){
        TrackPoint* point = fitTrack.getPoint(jhit);
        int ihit=point->getRawMeasurement(0)->getHitId();
        int detid=point->getRawMeasurement(0)->getDetId();
        //skip virtual hit
    //        if(ihit>=1000) continue;

        //skip point without fitted information
        if(!point->hasFitterInfo(rep)) continue;

        KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(point->getFitterInfo(rep));
        //get weights for LR combinations
        std::vector<double> dafWeights = fi->getWeights();

        //maximum weigth in fitting from LR positions
        int imaxdaf=std::distance(dafWeights.begin(),
                                  std::max_element(dafWeights.begin(),dafWeights.end()));
        double maxdaf=dafWeights[imaxdaf];


    //fill histogram with final chi2 per hit
    const MeasurementOnPlane& residual = fi->getResidual(imaxdaf, false, false);
    const TVectorD& resid(residual.getState());

        //dont fill StateVector forr skipped hits during fitting(in normal case hit must have weight=1.)
        if(maxdaf<0.5) {
          if(fDebug>9) std::cout<<"skip point "<<endl;
          continue;
        }

        //fill biased best StateVector on hit
        // (averaged from forward-backward propagation)
    const MeasuredStateOnPlane& state=fi->getFittedState(true);
    state.getPosMomCov(pos,mom,cov);

    //unbiased
    const MeasuredStateOnPlane& state2=fi->getFittedState(false);
    state2.getPosMomCov(pos2,mom2,cov2);

    if(detid==0){
      //average T0 shift over hits
      sumddist+=resid(0)*(imaxdaf?1:-1);
          ngoodhitsdch++;
        }else if(detid==1){
          ngoodhitssvx++;
        }else if(detid==2){
          ngoodhitspshw++;
        }

    if(detid<10){ //wire or svx or pshw hit
      aTrack->SetSkippedAt(ihit,false);
          *aTrack->GetStateVectorAt(ihit)=pos;
      ngoodhits++;
          if(detid==0){
            GMCDCHHit *ahit = (GMCDCHHit*) fBrHitsDC->At(aTrack->GethitindexAt(ihit));
            if(fDebug>9)
              cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" mes "<<0.1*ahit->GetfImpact()<<" dR not biased "<<resid(0)
                  <<" biased "<<0.1*ahit->GetfImpact()-fabs(state.getState()(3))<<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
            GetHResidualUnbiased()->Fill(10*fabs(state.getState()(3)),10*resid(0));
            GetHResidualBiased()->Fill(10*fabs(state.getState()(3)),ahit->GetfImpact()-10*fabs(state.getState()(3)));
          }else if(detid==1){
            GMCSVXHit *ahit = (GMCSVXHit*) fBrHitsSVX->At(aTrack->GethitindexAt(ihit));
            if(fDebug>9)
              cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                  <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
          }else if(detid==2){
            GMCPSHWHit *ahit = (GMCPSHWHit*) fBrHitsPSHW->At(aTrack->GethitindexAt(ihit));
            if(fDebug>9)
              cout<<detid<<" "<<ihit<<" track aver "<<state.getState()(3)<<" "<<state.getState()(4)<<" exact mes 0 0 dy,dz not biased "<<resid(0)<<" "<<resid(1)
                  <<" trk xyz "<<pos<<" mom "<<mom.Y()<<endl;
          }
    }
    // state.Print();
    // cov.Print();
    // state2.Print();
    // cov2.Print();
        if(ihit==aTrack->GethitindexAt(0))
          if(IsHMomentumActive()) GetHMomentum()->Fill(pmom0.Mag(),mom.Mag()/pmom0.Mag()-1);
    if(fDebug>9) {
          std::cout<<jhit<<" detid "<<detid<<" id "<<ihit<<" at hit "<<pos<<" "<<mom<<endl;
        }
      }
    }catch(Exception& e){
      if(fDebug) std::cout<<"on getting points "<<e.what()<<std::endl;
      fitstatus=false;
    }
    sumddist/=ngoodhitsdch;
    if(fDebug) std::cout<<" filtrated hits "<<numhits-ngoodhits<<" average ddist "<<sumddist/(0.4/150e-9)<<std::endl;
  }


  //-----------------------------------
  //propagate to target
  //-----------------------------------
  if(fitstatus){

    //force backward propagation(will be working forr only finite plane
    rep->setPropDir(-1);
    //take first fitted point
    TrackPoint* tp = fitTrack.getPointWithFitterInfo(0);
    if (tp == NULL) {std::cout << "Track has no TrackPoint with fitterInfo!(but fitstatus ok?)"<<std::endl;}
    KalmanFitterInfo* fi = static_cast<KalmanFitterInfo*>(tp->getFitterInfo(rep));
    MeasuredStateOnPlane state;

    //extrapolate rep to target plane
    bool isattarget=true;
    try{
      state=fi->getFittedState(true);
      rep->extrapolateToLine(state,TVector3(0,0,0),TVector3(0,0,1));
    }catch(Exception& e){
      if(fDebug) std::cout<<"on extrapolation to beam line "<<e.what()<<std::endl;
      isattarget=false;
    }
    double tof_target=1e9;
    if(isattarget){
      tof_target=state.getTime();
      state.getPosMomCov(pos,mom,cov);
      double momrec=mom.Mag();
      sigmap=momrec*momrec*TMath::Sqrt(state.getCov()(0,0));

    }
    if(fDebug)
      std::cout<<"vertex chi2 "<<fitStatus->getChi2()<<" ndf "<<fitStatus->getNdf()
           <<" nhits "<<nhits<<" dch "<<nhitsdch<<" svx "<<nhitssvx<<" pshw "<<nhitspshw<<" nfailed "<<fitStatus->getNFailedPoints()
               <<" P= "<<mom.Mag()*rep->getCharge(state)<<" +- "<<sigmap<<" fitok="<<fitstatus
           <<" pos "<<pos<<" mom "<<mom<<std::endl;
  }

  aTrack->Setx0(pos.X()*10);
  aTrack->Seterr_x0(sqrt(cov(0,0))*10);
  aTrack->Sety0(pos.Y()*10);
  aTrack->Seterr_y0(sqrt(cov(1,1))*10);
  aTrack->Setz0(pos.Z()*10);
  aTrack->Seterr_z0(sqrt(cov(2,2))*10);
  aTrack->Settheta(mom.Theta());
  aTrack->Seterr_theta(0.);
  aTrack->Setphi(mom.Phi());
  aTrack->Seterr_phi(0.);
  aTrack->SetMomentum(mom.Mag());
  aTrack->SetErr_Momentum(sigmap);
  aTrack->Setmom(mom);
  aTrack->Getcov()->ResizeTo(6,6);
  aTrack->Setcov(cov);

  //fill final information
  aTrack->Setnhits(nhits);
  aTrack->Setnhitsdch(nhitsdch);
  aTrack->Setnhitssvx(nhitssvx);
  aTrack->Setnhitspshw(nhitspshw);
  aTrack->Setchi2(fitStatus->getChi2());
  aTrack->Setdof(fitStatus->getNdf());
  aTrack->Setngoodhits(ngoodhits);
  aTrack->Setngoodhitsdch(ngoodhitsdch);
  aTrack->Setngoodhitssvx(ngoodhitssvx);
  aTrack->Setngoodhitspshw(ngoodhitspshw);
  aTrack->SetIsFitted(fitstatus);


  delete fitter;

  return true;
}

